import org.jenkinsci.plugins.workflow.libs.Library
@Library('jenkins-pipeline-shared-libraries')_

import org.kie.jenkins.MavenCommand

pipeline {

    agent {
        docker {
            image env.AGENT_DOCKER_BUILDER_IMAGE
            args env.AGENT_DOCKER_BUILDER_ARGS
            label util.avoidFaultyNodes('ubuntu')
        }
    }

    options{
        timestamps()
        timeout(time: 60, unit: 'MINUTES')
    }

    environment {
        // Static env is defined into .jenkins/dsl/jobs.groovy file
        KOGITO_CI_EMAIL_TO = credentials("${JENKINS_EMAIL_CREDS_ID}")
        HASH = "${util.generateHash(10)}"
    }

    stages{
        stage('CleanWorkspace') {
            steps {
                cleanWs(disableDeferredWipeout: true)
            }
        }
        stage('Initialize') {
            steps{
                script{
                    currentBuild.displayName = getRemoveBranch()

                    dir(getRepo()){
                        checkoutRepo(getRepo(), getGitAuthor(), getBuildBranch(), getGitAuthorCredsId())
                    }
                }
            }
        }
        stage('Create pull request branch') {
            steps{
                script{
                    dir(getRepo()){
                        githubscm.createBranch(getPrBranch())
                    }
                }
            }
        }
        stage('Remove branch from the main config') {
            steps {
                script{
                    dir(getRepo()){
                        // Update branch config
                        def config = readYaml file: env.CONFIG_FILE_PATH
                        // remove lines in yaml.file
                        config.git.branches = config.git.branches.findAll { it.name != "${getRemoveBranch()}" }
                        echo "Write dsl branch_config => ${config}"
                        sh "rm -f ${env.CONFIG_FILE_PATH}"
                        writeYaml file: "${env.CONFIG_FILE_PATH}", data: config, overwrite: true
                    }
                }
            }
        }
        stage('Push the changes'){
            steps {
                script {
                    dir(getRepo()){
                        String commitMsg = "[${getBuildBranch()}] DSL: Remove branch ${getRemoveBranch()}"
                        String localBranch = "${getPrBranch()}"
                        String targetBranch = "${getBuildBranch()}"
                        if (githubscm.isThereAnyChanges()) {
                            String prLink = commitAndCreatePR(commitMsg, localBranch, targetBranch)
                            approveAndMergePR(prLink)
                        } else {
                            println '[WARN] no changes to commit'
                        }
                    }
                }
            }
        }
    }
    post {
        unsuccessful {
            sendErrorNotification()
        }
    }
}

void checkoutRepo(String repo, String gitAuthor, String branch, String gitAuthorCredsId) {
    checkout(githubscm.resolveRepository(repo, gitAuthor, branch, false, gitAuthorCredsId))
    // need to manually checkout branch since on a detached branch after checkout command
    sh "git checkout ${branch}"
}

String getRepo(){
    return env.GIT_REPOSITORY
}

String getPrBranch() {
    return "remove-branch-${getRemoveBranch()}-${env.HASH}"
}

String getBuildBranch() {
    return env.GIT_BRANCH_TO_BUILD
}

void getRemoveBranch() {
    return params.BRANCH_TO_REMOVE
}

void getGitAuthorCredsId() {
    return env.GIT_AUTHOR_CREDENTIALS_ID
}

void getGitAuthorPushCredsId() {
    return env.GIT_AUTHOR_PUSH_CREDENTIALS_ID
}

void getGitAuthor() {
    return env.GIT_AUTHOR
}

void sendNotification(String body) {
    emailext body: "${body}",
             subject: "[${getBuildBranch()}] Pipelines",
             to: env.KOGITO_CI_EMAIL_TO
}

void sendErrorNotification() {
    sendNotification("Job #${BUILD_NUMBER} was: **${currentBuild.currentResult}**\nPlease look here: ${BUILD_URL}")
}

String commitAndCreatePR(String commitMsg, String localBranch, String targetBranch) {
    def prBody = "Generated by ${BUILD_URL}"
    githubscm.setUserConfigFromCreds(getGitAuthorPushCredsId())
    githubscm.commitChanges(commitMsg)
    githubscm.pushObject('origin', localBranch, getGitAuthorPushCredsId())
    return githubscm.createPR(commitMsg, prBody, targetBranch, getGitAuthorCredsId())
}

void approveAndMergePR(String prLink) {
    if (prLink?.trim()) {
        githubscm.approvePR(prLink, getGitAuthorPushCredsId())
        githubscm.mergePR(prLink, getGitAuthorPushCredsId())
    }
}
